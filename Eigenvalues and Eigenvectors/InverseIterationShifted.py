# -*- coding: utf-8 -*-
"""MN2Tarefa11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vcWSI-NYgnHacQYgrDI2umH0G3QcUjCM
"""

import numpy as np
import math

def potenciaInversa(A,v0, eps):
    autovalor1_novo = 0 #step 3
    vk_novo = v0.copy() #step 4
    (L,U) = decompLU(A)
    while True:
        autovalor1_velho = autovalor1_novo #step 5
        vk_velho = vk_novo.copy() #step 6
        vk_velho = normalize(vk_velho) #step 7
        vk_novo = solverLU(L,U,vk_velho) #step 8
        autovalor1_novo = np.dot(np.transpose(vk_velho),vk_novo) #step 9
        if (abs((autovalor1_novo - autovalor1_velho)/autovalor1_novo) <= eps):
            break #step 10
    autovalor_n = 1/autovalor1_novo #step 11
    xn = vk_novo.copy()#*10 #step 12


    #Ajuste dos valores do vetor (em função de x3 (xn[2]))
    if len(A)>=3:
      k = 1/xn[2]
      for i in range (0,len(xn)): 
        xn[i] = xn[i]*(k)

    vetor = [autovalor_n, xn]
    return vetor #step 13
    

def potenciaDeslocamento(A,v0,eps,u):
  At = copy(A)
  At = At - np.dot(identity(len(A)),u)
  
  (autovalor,autovetor) = potenciaInversa(At,v0, eps)
  autovalor_i = autovalor + u
  x_i = autovetor
  return (autovalor,autovetor)


def identity(n):
  M = []
  for i in range(0,n):
    linha = []
    for j in range(0,n):
      if j == i:
        linha.append(1)
      else:
        linha.append(0)
    M.append(linha)
  return M


def normalize(vk_velho):
    n = len(vk_velho)
    valor = 0
    vetor = [0]*n
    for i in range(0,n):
        valor = valor + vk_velho[i]**2
    valor = math.sqrt(valor)
    for i in range(0,n):
        vetor[i] = vk_velho[i]/valor
    return vetor

def copy(A):
    M = []
    for i in range(0,len(A[0])):
        linha = []
        for j in range(0,len(A)):
            linha.append(A[i][j])
        M.append(linha)
    return M


def solverLU(L,U,x):
    a = np.linalg.solve(L,x)
    b = np.linalg.solve(U,a)
    return b

def subVetores(A,B):
    resultado = []
    for i in range(0,len(A)):
        resultado.append(A[i] - B[i])
    return resultado


def decompLU(A):
    L = copy(A)
    U = copy(A)
    for i in range(0,len(A[0])):
        for j in range(0,len(A)):
            if i > j :
                L[i][j] = (A[i][j]/A[j][j])
                k = L[i][j]  
                U[i] = subVetores(U[i],(np.dot(U[j],k))) #subtrair linhas
            
            elif i == j:
                L[i][j] = 1
            else :
                L[i][j] = 0
    return L,U

#--------------------MAIN----------------------

A1 = [[5,2,1],
      [2,3,1],
      [1,1,2]]

A2 = [[-14,1,-2],
      [1,-1,1],
      [-2,1,-11]]     

A3 = [[40,8,4,2,1 ],
      [8,30,12,6,2],
      [4,12,20,1,2],
      [2,6,1,25,4 ],
      [1,2,2,4,5  ]]


v0 = [10,10,10]
v1 = [1,1,1,1,1]
eps = 0.00001
#step 1

#RESULTADOS PARA MÉTODO DA POTÊNCIA INVERSA
print("\n-------------Potência Inversa-------------\n")
#PARA MATRIZ A1
a1result = potenciaInversa(A1,v0,eps)
print("Autovalor de A1: ",a1result[0],"\nAutovetor = ", a1result[1])

#PARA MATRIZ A2
a2result = potenciaInversa(A2,v0,eps)
print("\nAutovalor de A2: ",a2result[0],"\nAutovetor = ", a2result[1])

#PARA MATRIZ A3
a3result = potenciaInversa(A3,v1,eps)
print("\nAutovalor de A3: ",a3result[0],"\nAutovetor = ", a3result[1])

#Potência deslocada
u = 1
a1result1 = potenciaDeslocamento(A1,v0,eps,u)
print("\n-------------Potência com deslocamento:-------------\n")
print("Autovalor de A1: ",a1result1[0],"\nAutovetor = ", a1result1[1])

a2result2 = potenciaDeslocamento(A2,v0,eps,u)
print("\nAutovalor de A2: ",a2result2[0],"\nAutovetor = ", a2result2[1])

a3result3 = potenciaDeslocamento(A3,v1,eps,u)
print("\nAutovalor de A3: ",a3result3[0],"\nAutovetor = ", a3result3[1])