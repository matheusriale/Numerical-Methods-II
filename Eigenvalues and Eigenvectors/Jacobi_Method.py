# -*- coding: utf-8 -*-
"""Tarefa12_Jacobi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n9QbpYVEnQs8R0j5MWK66O-R3M5_Lg9A
"""

import numpy as np
import math

def identity(n):
  M = []
  for i in range(0,n):
    linha = []
    for j in range(0,n):
      if j == i:
        linha.append(1)
      else:
        linha.append(0)
    M.append(linha)
  return M

def roundMatrizes(M,n):
  R = []
  linhas = []
  for i in range(0,n):
    for j in range(0,n):
      linhas.append(round(M[i][j],2))
    R.append(linhas)
    linhas = []
  
  return R



def varreduraJacobiAlterada(A,n): #Para receber matriz tridiagonal
  J = identity(n)
  A_velha = A.copy()
  varr = []
  for j in range(0,n-1):
    for i in range(j+1,n): #cuidado com os indices
      J_ij = matrizJacobi(A,i,j,n).copy()
      A_nova = np.dot(np.dot(np.transpose(J_ij),A_velha),J_ij)
      varr.append(A_nova)
      A_velha = A_nova.copy()
      J = np.dot(J,J_ij)
  A_linha = A_nova.copy()
  for i in range(0,len(varr)):
    varr[i] = roundMatrizes(varr[i],5)
  return (A_linha,J,varr)

def metodoDeJacobiAlterado(A,n,eps):
  lamb = []
  #varr = []
  val = 100.0
  P = identity(n)
  A_velha = A.copy()
  while (val > eps):
    (A_nova,J,varr) = varreduraJacobiAlterada(A_velha,n)
    for j in (varr):
      print("")
      for i in j:
        print(i)
        
    
    A_velha = A_nova.copy()
    P = np.dot(P,J)
    val = somaQuadradosAbaixoDiagonal(A_nova,n)
  for i in range(0,n):
    lamb.append(A_nova[i][i])
  for i in range(0,n):
    for j in range(0,n):    #Formatar autovetores, por todos eles em função de x5
      k = 1/P[4][j]
      P[i][j] = P[i][j] * k
  for i in range(0,len(varr)):
    varr[i] = roundMatrizes(varr[i],5)
  A_nova = roundMatrizes(A_nova,5)
  # for i in A_nova:      #Verificar se A_nova é diagonal printar
  #   print(i)
  P = roundMatrizes(P,5)
  return (P,lamb,A_nova,varr)




def matrizJacobi(A,i,j,n):
  eps = 0.000001
  J_ij = identity(n)
  if (abs(A[i][j])<= eps ):
    return J_ij
  if (abs(A[i][i]-A[j][j]) <= eps):
    theta = math.pi/4
  else:
    theta = (1/2)*math.atan(-2*A[i][j]/(A[i][i] - A[j][j]))

  J_ij[i][i] = math.cos(theta)
  J_ij[j][j] = math.cos(theta)
  J_ij[i][j] = math.sin(theta)
  J_ij[j][i] = -math.sin(theta)

  return J_ij

def varreduraJacobi(A,n):
  J = identity(n)
  A_velha = A.copy()
  
  for j in range(0,n-1):
    for i in range(j+1,n): #cuidado com os indices
      J_ij = matrizJacobi(A,i,j,n).copy()
      A_nova = np.dot(np.dot(np.transpose(J_ij),A_velha),J_ij)
      A_velha = A_nova.copy()
      J = np.dot(J,J_ij)
  A_linha = A_nova.copy()
  return (A_linha,J)






def somaQuadradosAbaixoDiagonal(A,n):
  valor = 0
  R = A.copy()
  for i in range(0,n):   
    for j in range(0,n):
      if i>j:
        valor = valor + (R[i][j]**2)
  return valor

def metodoDeJacobi(A,n,eps):
  lamb = []
  varr = []
  val = 100.0
  P = identity(n)
  A_velha = A.copy()
  while (val > eps):
    (A_nova,J) = varreduraJacobi(A_velha,n)
    varr.append(A_nova)
    
    A_velha = A_nova.copy()
    P = np.dot(P,J)
    val = somaQuadradosAbaixoDiagonal(A_nova,n)


  for i in range(0,n):
    lamb.append(A_nova[i][i])

  
  for i in range(0,n):
    for j in range(0,n):    #Formatar autovetores, por todos eles em função de x5
      k = 1/P[4][j]
      P[i][j] = P[i][j] * k

  for i in range(0,len(varr)):
    varr[i] = roundMatrizes(varr[i],5)

  A_nova = roundMatrizes(A_nova,5)
  # for i in A_nova:      #Verificar se A_nova é diagonal printar
  #   print(i)


  return (P,lamb,A_nova,varr)



A = [[40,8,4,2,1],
     [8,30,12,6,2],
     [4,12,20,1,2],
     [2,6,1,25,4],
     [1,2,2,4,5 ]]


# v = matrizJacobi(A,1,2,5)
# print(v)
v = metodoDeJacobi(A,5,0.0001)

autovetores = np.transpose(v[0])

#1. I) Matriz A diagonal
print("--------Matriz A_linha diagonal--------")
for i in v[2]:
  print(i)

#II)
print("\n--------Matriz P acumulada (Matriz dos autovetores)--------")
for i in v[0]:
  print(i)
#III)
'''
print("\n--------Matrizes A que saem a cada varredura de Jacobi--------")
for i in v[3]:
  for j in i:
    print(j)
  print("")
'''
#IV)
print("\n--------Pares Autovalor, Autovetor da matriz A--------")
for i in range(0,5):
  print(v[2][i][i],autovetores[i])
  
#2.I) Adaptar para varredura de Jacobi receber tridiagonal de Householder
A_tridiagonal = [[40.0, 9.22, 0.0, -0.0, -0.0],
                  [9.22, 39.82, 4.07, -0.0, -0.0],
                  [0.0, 4.07, 15.07, 6.29, 0.0],
                  [-0.0, -0.0, 6.29, 17.59, 5.87],
                  [-0.0, 0.0, 0.0, 5.87, 7.52]]
'''
#II) Imprimir A_nova a cada iteração 
print("\nImprimir A_nova a cada iteração ")
v2 = metodoDeJacobiAlterado(A_tridiagonal,5,0.0001)
'''
#III) Imprimir P para verificar se suas colunas são autovetores de A

print("\nMatriz P")
for i in v2[0]:
  print(i)

#IV) 
print("\nVerificar, P = HP , P é matriz dos autovetores de A")
H=[[1.0, 0.0, 0.0, 0.0, 0.0], #Matriz resultante H da tarefa anterior
  [0.0, 0.87, -0.44, 0.09, 0.21],
  [0.0, 0.43, 0.55, -0.6, -0.38],
  [0.0, 0.22, 0.7, 0.59, 0.34],
  [0.0, 0.11, -0.08, 0.53, -0.84]]

P = np.dot(H,v2[0])
for i in range(0,5):
    for j in range(0,5):    #Formatar autovetores, por todos eles em função de x5
      k = 1/P[4][j]
      P[i][j] = P[i][j] * k
P = roundMatrizes(P,5)
for i in P:
  print(i)

