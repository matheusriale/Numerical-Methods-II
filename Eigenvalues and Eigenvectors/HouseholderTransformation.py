# -*- coding: utf-8 -*-
"""Tarefa12_Householder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xG8Y_wtk0GYkPqRnVduGWTJhB54vmIIt
"""

import numpy as np
import math

def identity(n):
  M = []
  for i in range(0,n):
    linha = []
    for j in range(0,n):
      if j == i:
        linha.append(1)
      else:
        linha.append(0)
    M.append(linha)
  return M

def isSymmetricMatrix(): #checar se a matriz dada é simetrica
  return 

def copy(A):
    M = []
    for i in range(0,len(A[0])):
        linha = []
        for j in range(0,len(A)):
            linha.append(A[i][j])
        M.append(linha)
    return M


def vectorLength(v): #norma do vetor
  n = len(v)
  valor = 0
  for i in range(0,n):
    valor = valor + (v[i]**2)
  valor = valor**(1/2)
  return valor

def subVetores(A,B):
    resultado = []
    for i in range(0,len(A)):
        resultado.append(A[i] - B[i])
    return resultado

def divVetor(A,const):
  n = len(A)
  R = [0]*n
  for i in range(0,n):
    R[i] = A[i]/const
  
  return R

def multVetor(v,w):
  linhas_v = len(v)
  col_w = len(w)
  
  A = []
  for i in range(0,linhas_v):
    linhas = []
    for j in range(0,col_w):
      linhas.append(v[i]*w[j])
    A.append(linhas)
  return A

def multMatrizes(A,B,n): 
  R = []
  valor = 0
  for i in range(0,n):
    linhas = []
    for j in range(0,n):
      for k in range(0,n):
        valor = valor + A[i][k]*B[k][j]
      linhas.append(valor)
      valor = 0
    R.append(linhas)
  return R

def subMatrizes(A,B,n): 
  R = []
  valor = 0
  for i in range(0,n):
    linhas = []
    for j in range(0,n):
      valor = A[i][j] - B[i][j]
      linhas.append(valor)
    R.append(linhas)
  return R

def roundMatrizes(M,n):
  R = []
  linhas = []
  for i in range(0,n):
    for j in range(0,n):
      linhas.append(round(M[i][j],2))
    R.append(linhas)
    linhas = []
    

  return R

def matrizHouseholder(A,i,n):
  #n = len(A)
  w =  [0]*n
  wl = [0]*n
  e =  [0]*n #vetores nulos com n elementos
  #devemos copiar os elementos abaixo da diagonal da coluna i da matriz A
  #para as respectivas posições no vetor w, isto é da posição i+1 até o final.
  for j in range(i+1,n):
    w[j] = A[j][i]

  Lw = vectorLength(w) #calcular comprimento de w

  wl[i+1] = Lw #copiar Lw na posição i+1 do vetor w' (wl)

  N = subVetores(w,wl)

  n_normalizado = divVetor(N,vectorLength(N))#normalizar vetor N

  H = subMatrizes(identity(n),np.multiply(multVetor(n_normalizado,np.transpose(n_normalizado)),2),5)#montar a matriz de Householder 

  return H

def metodoHouseholder(A,n):
  #n = len(A) # n é a dimensão da matriz quadrada A
  H = identity(n)
  A_anterior = copy(A) #.copy() ou copy(A) (função criada na tarefa 11)
  for i in range(0,n-2):
    
    H_i = matrizHouseholder(A_anterior,i,5) #construção da matriz de Householder do passo i

    A_i = multMatrizes(np.transpose(H_i),multMatrizes(A_anterior,H_i,5),5) #transformação de similaridade do passo i
    
    A_anterior = copy(A_i) #salvar para proximo passo
    
    H = multMatrizes(H,H_i,5) #acumular o produto das matrizes de Householder

  solution = (A_i,H)
  return solution



def met_potencia(autovalor1,vk_novo,error,A):
  x1_velho = [0]*len(vk_novo)
  while True:
    autovalor0 = autovalor1 #Step 4
    vk_velho = vk_novo.copy() #Step 5
    x1_velho = normalize(vk_velho) #Step 6
    vk_novo = np.dot(A,x1_velho)#Step 7 
    autovalor1 = np.dot(np.transpose(x1_velho),vk_novo) #Step 8
    if (abs((autovalor1 - autovalor0)/autovalor1) <= error): #Step 9
      break 
    vetor = [autovalor1, x1_velho]
  return vetor #Step 10

def normalize(vk_velho):
  n = len(vk_velho)
  valor = 0
  vetor = [0]*n
  for i in range(0,n):
    valor = valor + vk_velho[i]**2
  valor = math.sqrt(valor)
  for i in range(0,n):
    vetor[i] = vk_velho[i]/valor
  return vetor


A = [[40,8,4,2,1],
     [8,30,12,6,2],
     [4,12,20,1,2],
     [2,6,1,25,4],
     [1,2,2,4,5 ]]

v = metodoHouseholder(A,5)
#v[0] #matriz tridiagonal
#v[1] #matriz acumulada H
A_Tridiagonal = roundMatrizes(v[0],5) #arredondar matrizes tridiagonal e H acumulada
H_Acumulada = roundMatrizes(v[1],5)

#1)
print("\n-----------Matriz tridiagonal-----------")
for i in A_Tridiagonal:
  print(i)

print("\n-----------Matriz H acumulada-----------")
for i in H_Acumulada:
  print(i)

#3) Aplicar metodo da potencia em A_tridiagonal
autovalor1 = 0
vk_novo = [1,1,1,1,1]
error = 0.001
v3 = met_potencia(autovalor1,vk_novo,error,A_Tridiagonal)

print("\n-----------Autovalor de A_tridiagonal-----------")
print(v3[0])
print("\n-----------Autovetores de A_tridiagonal-----------")
print(v3[1])
#4)
print("\n-----------Encontrar Autovetor de A a partir de Autovetor de A_tridiagonal-----------")
print(np.dot(H_Acumulada,v3[1])) # a partir de H e Autovetor da tridiagonal
v4 = met_potencia(autovalor1,vk_novo,error,A)
#5)
print("\n-----------Encontrar Autovalor de A-----------")
print(v4[0]) # a partir de H e Autovetor da tridiagonal

